{"note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Recorder dumps the result of your ruby code to a YAML file for faster tests or to compare the result between two runs.","google":"","name":"Ruby-recorder","body":"# Ruby Recorder\r\n\r\n[![Build Status](https://secure.travis-ci.org/mickey/ruby-recorder.png)](http://travis-ci.org/mickey/ruby-recorder)\r\n\r\nRecorder dumps the result of your ruby code to a YAML file for faster tests or to compare the result between two execution.\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'ruby-recorder'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install ruby-recorder\r\n\r\n## Exemples\r\n\r\n### Refactor\r\n\r\nImagine you want to refactor an endpoint on your backend api and want to make sure the response is the same:\r\n\r\n```\r\n  Recorder.config do |c|\r\n    c.verbose = true\r\n    c.stubb = false\r\n  end\r\n\r\n  # this will call your backend and \r\n  # dump the result in refactor.yml\r\n  # let's say the response is : [{\"username\"=>\"Michael Bensoussan\"}]\r\n  Recorder.dump_to('refactor.yml') do\r\n    HTTParty.get('http://my_backend/users').parsed_response\r\n  end\r\n\r\n  # this will call your backend and compare the result to\r\n  # what's in refactor.yml ([{\"username\"=>\"Michael Bensoussan\"}])\r\n  # let's say the new response is [{\"username\"=>\"Michael\"}]\r\n  Recorder.dump_to('refactor.yml') do\r\n    HTTParty.get('http://my_backend/users').parsed_response\r\n  end\r\n\r\n```\r\n\r\nExecuting this code will outputs a (colored) diff :\r\n\r\n```\r\n  Recorder: result is different from last run\r\n  ---\r\n  - username: Michael Bensoussan- username: Michael\r\n```\r\n\r\n### Faster tests\r\n\r\nThe first time you run this test, you will call the backend but for all the following runs `Recorder` will load the result from the YAML file.\r\n\r\n```\r\n  class TestRecorder < MiniTest::Unit::TestCase\r\n\r\n    def setup\r\n      Recorder.config do |c|\r\n        c.verbose = true\r\n        c.stubb = true\r\n        c.records_dir = 'backend_responses/'\r\n      end\r\n    end\r\n\r\n    def test_users\r\n      users = Recorder.dump_to('refactor.yml') do\r\n        HTTParty.get('http://my_backend/users').parsed_response\r\n      end\r\n\r\n      assert_equal [{\"username\"=>\"Michael Bensoussan\"}], users\r\n    end\r\n\r\n  end\r\n```\r\n\r\n## Usage\r\n\r\n```\r\n  Recorder.config do |c|\r\n    c.verbose = true\r\n    c.records_dir = 'records/'\r\n    c.stubb = false\r\n  end\r\n```\r\n\r\n### records_dir\r\n\r\nThe `records_dir` option sets the directory where your records will be saved.\r\n\r\n### stubb\r\n\r\nWhen `stubb = true`, your code will only be run once. Future runs will load the result from the yaml file.\r\nWhen `stubb = false`, your code will be run every time.\r\n\r\n### verbose\r\n\r\nThe `verbose` option will outputs a nice diff (with the `differ` gem) if the output is different from the last run.\r\nOf course this only works if `stubb = false`.\r\n\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Added some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n"}